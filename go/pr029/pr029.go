//////////////////////////////////////////////////////////////////////
// Problem 29
//
// Published on Friday, 25th October 2002, 06:00 pm; Solved by 39544
//
// Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤
// 5:
//
//     2^2=4, 2^3=8, 2^4=16, 2^5=32
//     3^2=9, 3^3=27, 3^4=81, 3^5=243
//     4^2=16, 4^3=64, 4^4=256, 4^5=1024
//     5^2=25, 5^3=125, 5^4=625, 5^5=3125
//
// If they are then placed in numerical order, with any repeats
// removed, we get the following sequence of 15 distinct terms:
//
// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
//
// How many distinct terms are in the sequence generated by a^b for 2 ≤
// a ≤ 100 and 2 ≤ b ≤ 100?
//
//////////////////////////////////////////////////////////////////////
// 9183

package pr029

import "github.com/d3zd3z/euler/go/euler"
import "fmt"
import "sort"

func Run() {
	var sieve euler.Sieve

	all := make([][]euler.Factor, 0, 10000)
	for a := 2; a <= 100; a++ {
		for b := 2; b <= 100; b++ {
			tmp := factorPower(sieve.Factorize(a), b)
			all = append(all, tmp)
		}
	}
	sort.Sort(Nodes(all))
	all = unique(all)
	fmt.Printf("%v\n", len(all))
}

func factorPower(factors []euler.Factor, exp int) (result []euler.Factor) {
	result = make([]euler.Factor, 0, len(factors))
	for _, fact := range factors {
		result = append(result,
			euler.Factor{Prime: fact.Prime, Power: exp * fact.Power})
	}
	return
}

func unique(factors [][]euler.Factor) (result [][]euler.Factor) {
	result = make([][]euler.Factor, 0, 500)

	for pos, _ := range factors {
		if pos+1 >= len(factors) || !equal(factors[pos], factors[pos+1]) {
			result = append(result, factors[pos])
		}
	}
	return
}

// Maps can't deal with slices in Go, and there is no general map or set library.
type Nodes [][]euler.Factor

func (p Nodes) Len() int { return len(p) }
func (p Nodes) Less(i, j int) bool {
	pos := 0
	for {
		if pos >= len(p[i]) && pos >= len(p[j]) {
			return false
		}
		if pos >= len(p[i]) {
			return false
		}
		if pos >= len(p[j]) {
			return true
		}
		if p[i][pos].Prime < p[j][pos].Prime {
			return true
		}
		if p[i][pos].Prime > p[j][pos].Prime {
			return false
		}
		if p[i][pos].Power < p[j][pos].Power {
			return true
		}
		if p[i][pos].Power > p[j][pos].Power {
			return false
		}
		pos++
	}
	panic("Not reached")
}
func (p Nodes) Swap(i, j int) { p[i], p[j] = p[j], p[i] }

func equal(a, b []euler.Factor) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}
