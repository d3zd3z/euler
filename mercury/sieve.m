:- module sieve.

:- interface.
:- import_module list.

:- type sieve.

% Generate a new sieve with the given limit.  It will be valid for detecting
% primes up to, but not including this limit.
:- func new_sieve(int) = sieve.

% New sieve with a default size.
:- func new_sieve = sieve.

% Possibly regenerate a sieve, to make sure it can compute primes up to, and
% not including Size.
:- pred ensure_size(int::in, sieve::in, sieve::out) is det.

% Given a sieve, return the primes contained in it.
:- func get_primes(sieve) = list(int).

%------------------------------------------------------------%

:- implementation.
:- import_module bool.
:- import_module int.
:- import_module list.
:- import_module array.

% The fastest type to use is just an array of bools.  Sets work, but are about
% an order of magnitude slower.

% A sieve is a set of the composites, and the limit for which those composites
% were computed to.
:- type sieve
    --->    sieve(
                sieve_primes      :: array(bool),
                sieve_size        :: int
            ).

new_sieve = new_sieve(1024).

new_sieve(Size) = sieve(!:C, Size) :-
    !:C = init(Size, yes),
    set(0, no, !C),
    set(1, no, !C),
    update(4, 2, Size, !C),
    walk(3, Size, !C).

ensure_size(Size, !S) :-
    ( if Size < !.S ^ sieve_size then
        true
    else
        Size2 = next_size(Size, Size),
        !:S = new_sieve(Size2)
    ).

% To make sure this grows reasonably, compute the better size.
:- func next_size(int, int) = int.
next_size(Need, Cur) = Next :-
    ( if Need < Cur then
        Next = Cur
    else
        Next = next_size(Need, Cur * 8)
    ).

% Get all of the primes out of the sieve.
get_primes(sieve(C, Size)) = L :-
    L = int.fold_up(getp(C), 2, Size-1, []).

:- func getp(array(bool), int, list(int)) = list(int).
getp(C, N, L) = L2 :-
    ( if lookup(C, N) = no then
        L2 = L
    else
        L2 = [N | L]
    ).

% Walk through the primes, marking all of the composites generated by them.
:- pred walk(int::in, int::in,
    array(bool)::array_di, array(bool)::array_uo).
walk(Pos, Limit, !C) :-
    ( if Pos >= Limit then
        true
    else if lookup(!.C, Pos) = no then
        walk(Pos + 2, Limit, !C)
    else
        update(Pos + Pos, Pos, Limit, !C),
        walk(Pos + 2, Limit, !C)
    ).

% Update the sieve to include all composite from prime P.
:- pred update(int::in, int::in, int::in,
    array(bool)::array_di, array(bool)::array_uo).
update(Pos, Inc, Limit, !C) :-
    ( if Pos < Limit then
        set(Pos, no, !C),
        update(Pos+Inc, Inc, Limit, !C)
    else
        true).
