:- module pr012.

% Problem 12
%
% 08 March 2002
%
% The sequence of triangle numbers is generated by adding the natural
% numbers. So the 7^th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 =
% 28. The first ten terms would be:
%
% 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
%
% Let us list the factors of the first seven triangle numbers:
%
%      1: 1
%      3: 1,3
%      6: 1,2,3,6
%     10: 1,2,5,10
%     15: 1,3,5,15
%     21: 1,3,7,21
%     28: 1,2,4,7,14,28
%
% We can see that 28 is the first triangle number to have over five
% divisors.
%
% What is the value of the first triangle number to have over five hundred
% divisors?
%
% 76576500

:- interface.
:- import_module io.
:- pred main(io::di, io::uo) is det.

:- implementation.
:- import_module int.
:- import_module list.
:- import_module string.
:- import_module sieve.

main(!IO) :-
    Sieve = new_sieve(1024),
    solve(1, 1, Sieve, _, Answer),
    io.print(Answer, !IO),
    io.nl(!IO).

:- pred solve(int::in, int::in, sieve::in, sieve::out, int::out) is det.
solve(N, Tri, !S, Result) :-
    divisor_count(Tri, !S, Count),
    % trace [io(!IO)] (io.format("solve N:%d Tri:%d, Count:%d\n", [i(N), i(Tri), i(Count)], !IO)),
    ( if Count > 500 then
        Result = Tri
    else
        N2 = N + 1,
        solve(N2, Tri + N2, !S, Result)
    ).

% Given a prime sieve, count the number of positive divisors of the number 'N'.
% Returns a new sieve, because the sieve may need to be grown.
:- pred divisor_count(int::in, sieve::in, sieve::out, int::out) is det.
divisor_count(N, !S, Result) :-
    ensure_size(N+1, !S),
    Result = dcloop(!.S, N, 2, 1).

:- func dcloop(sieve, int, int, int) = int.
dcloop(S, N, P, Work) = Res :-
    % trace [io(!IO)] (io.format("dcloop N:%d P:%d Work:%d\n", [i(N), i(P), i(Work)], !IO)),
    ( if N = 1 then
        Res = Work
    else if N mod P = 0 then
        {N2, Count} = multi_divide(N, P, 0),
        % The extra complexity to keep the primes from running past 'N'.
        ( if N2 > 1 then
            P2 = next_prime(S, P),
            Res = dcloop(S, N2, P2, Work * (Count + 1))
        else
            Res = Work * (Count + 1)
        )
    else
        P2 = next_prime(S, P),
        Res = dcloop(S, N, P2, Work)
    ).

:- func multi_divide(int, int, int) = {int, int}.
multi_divide(N, P, Count) = Result :-
    % trace [io(!IO)] (io.format("multi_divide N:%d p:%d Count:%d\n", [i(N), i(P), i(Count)], !IO)),
    ( if N mod P = 0 then
        Result = multi_divide(N // P, P, Count + 1)
    else
        Result = {N, Count}
    ).
