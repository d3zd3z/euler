----------------------------------------------------------------------
--  Problem 29

--
--  25 October 2002
--
--  Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and
--  2 ≤ b ≤ 5:
--
--      2^2=4, 2^3=8, 2^4=16, 2^5=32
--      3^2=9, 3^3=27, 3^4=81, 3^5=243
--      4^2=16, 4^3=64, 4^4=256, 4^5=1024
--      5^2=25, 5^3=125, 5^4=625, 5^5=3125
--
--  If they are then placed in numerical order, with any repeats removed, we
--  get the following sequence of 15 distinct terms:
--
--  4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
--
--  How many distinct terms are in the sequence generated by a^b for
--  2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
--
----------------------------------------------------------------------

with Ada.Text_IO; use Ada.Text_IO;
--  with Euler; use Euler;
with Ada.Containers; use Ada.Containers;
with Ada.Containers.Hashed_Sets;
with Prime_Sieve;

procedure Pr029 is

   use type Prime_Sieve.Factor;

   --  This code assumes that 'Prime_Sieve.Factorize' returns the factors in
   --  order.

   --  Instead of doing bignum computations for the full numbers, represent
   --  each number as the powers of it's prime factors.
   subtype Power_Type is Prime_Sieve.Factor_Vectors.Vector;

   procedure Power (
      Number : out Power_Type;
      Base : Natural; Exponent : Natural);
   --  Raise 'Base' to 'Exponent'.

   procedure Power (
      Number : out Power_Type;
      Base : Natural; Exponent : Natural)
   is
      procedure Change (Element : in out Prime_Sieve.Factor);
      procedure Change (Element : in out Prime_Sieve.Factor) is
      begin
         Element.Power := Element.Power * Exponent;
      end Change;
   begin
      Number := Prime_Sieve.Factorize (Base);
      for I in Number.First_Index .. Number.Last_Index loop
         Number.Update_Element (I, Change'Access);
      end loop;
   end Power;

   function Hash (Element : Power_Type) return Hash_Type;
   function Equivalent_Elements (Left, Right : Power_Type)
      return Boolean;
   function "=" (Left, Right : Power_Type) return Boolean;

   package Factor_Set is new Ada.Containers.Hashed_Sets (
      Element_Type => Power_Type,
      Hash => Hash,
      Equivalent_Elements => Equivalent_Elements);

   Hash_Factor : constant := 2954435769;

   function Hash (Element : Power_Type) return Hash_Type is
      Result : Hash_Type := 0;
   begin
      for F of Element loop
         Result := Result * Hash_Factor;
         Result := Result + Hash_Type (F.Prime);
         Result := Result * Hash_Factor;
         Result := Result + Hash_Type (F.Power);
      end loop;

      return Result;
   end Hash;

   function Equivalent_Elements (Left, Right : Power_Type)
      return Boolean
   is
   begin
      if Left.First_Index /= Right.First_Index or else
         Left.Last_Index /= Right.Last_Index
      then
         return False;
      end if;

      for I in Left.First_Index .. Left.Last_Index loop
         if Left (I) /= Right (I) then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent_Elements;

   function "=" (Left, Right : Power_Type) return Boolean is
   begin
      raise Program_Error;
      return Equivalent_Elements (Left, Right);
   end "=";

   --  procedure Show (Element : Power_Type);
   --  procedure Show (Element : Power_Type) is
   --  begin
   --     Put_Line (Hash (Element)'Img);
   --     Prime_Sieve.Dump_Factors (Element);
   --  end Show;

   Values : Factor_Set.Set;
   Temp : Power_Type;
   --  Pos : Factor_Set.Cursor;

begin
   for A in 2 .. 100 loop
      for B in 2 .. 100 loop
         Power (Temp, A, B);

         Values.Include (Temp);
      end loop;
   end loop;

   --  GRR: This seems to be off by one.
   Put_Line (Count_Type'Image (Values.Length));
end Pr029;
