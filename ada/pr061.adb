----------------------------------------------------------------------
--  Problem 61
--
--  16 January 2004
--
--
--  Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
--  numbers are all figurate (polygonal) numbers and are generated by the
--  following formulae:
--
--  Triangle     P[3,n]=n(n+1)/2    1, 3, 6, 10, 15, ...
--  Square       P[4,n]=n^2         1, 4, 9, 16, 25, ...
--  Pentagonal   P[5,n]=n(3n−1)/2   1, 5, 12, 22, 35, ...
--  Hexagonal    P[6,n]=n(2n−1)     1, 6, 15, 28, 45, ...
--  Heptagonal   P[7,n]=n(5n−3)/2   1, 7, 18, 34, 55, ...
--  Octagonal    P[8,n]=n(3n−2)     1, 8, 21, 40, 65, ...
--
--  The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
--  interesting properties.
--
--   1. The set is cyclic, in that the last two digits of each number is
--      the first two digits of the next number (including the last
--      number with the first).
--   2. Each polygonal type: triangle (P[3,127]=8128), square (P[4,91]=
--      8281), and pentagonal (P[5,44]=2882), is represented by a
--      different number in the set.
--   3. This is the only set of 4-digit numbers with this property.
--
--  Find the sum of the only ordered set of six cyclic 4-digit numbers
--  for which each polygonal type: triangle, square, pentagonal,
--  hexagonal, heptagonal, and octagonal, is represented by a different
--  number in the set.
--
--  28684
----------------------------------------------------------------------

with Ada.Containers;
with Ada.Text_IO; use Ada.Text_IO;
--  with Euler; use Euler;

--  Grab the vectors type from the sieve.
with Prime_Sieve;
with Permutations;

procedure Pr061 is

   package Natural_Vectors renames Prime_Sieve.Natural_Vectors;
   subtype Natural_Vector is Natural_Vectors.Vector;

   function Get_In_Range (Low, High : Natural;
                          Generate : access function (N : Natural)
                            return Natural)
                         return Natural_Vector;
   --  Return an array allocated with all of the values returned by
   --  'Generate' that fall within 'Low'..'High' (inclusive).
   --  Generate is assumed to be monotonically increasing, as well as
   --  to have Generate (1) with values <= Low.  Generate will also be
   --  called more than one time for a given 'N'.

   function Fig_Triangle   (N : Natural) return Natural;
   function Fig_Square     (N : Natural) return Natural;
   function Fig_Pentagonal (N : Natural) return Natural;
   function Fig_Hexagonal  (N : Natural) return Natural;
   function Fig_Heptagonal (N : Natural) return Natural;
   function Fig_Octagonal  (N : Natural) return Natural;
   --  Generators for the various figurate sequences.

   type Index_Type is mod 6;
   Generators : constant array (Index_Type) of
     access function (N : Natural) return Natural :=
     (Fig_Triangle'Access,
      Fig_Square'Access,
      Fig_Pentagonal'Access,
      Fig_Hexagonal'Access,
      Fig_Heptagonal'Access,
      Fig_Octagonal'Access);

   type Sequence_Type is array (Index_Type) of Natural_Vector;

   Base_Sequence : Sequence_Type;

   procedure Initialize_Base;
   --  Initialize the above base sequence.

   procedure Reduce (Source :        Natural_Vector;
                     Dest   : in out Natural_Vector);
   --  Reduce the Destination vector, including only those entries
   --  that are "reachable" from an entry in the source.

   type Flatten_Result is (Solved, No_Solution);

   procedure Full_Reduce (Sequence : in out Sequence_Type;
                          Result   :    out Flatten_Result);
   --  Repeat the reduce step until there is either a unique solution,
   --  or no solution at all, setting Result appropriately.

   ------------------
   -- Fig_Triangle --
   ------------------

   function Fig_Triangle   (N : Natural) return Natural is
   begin
      return N * (N + 1) / 2;
   end Fig_Triangle;

   ----------------
   -- Fig_Square --
   ----------------

   function Fig_Square     (N : Natural) return Natural is
   begin
      return N * N;
   end Fig_Square;

   --------------------
   -- Fig_Pentagonal --
   --------------------

   function Fig_Pentagonal (N : Natural) return Natural is
   begin
      return N * (3 * N - 1) / 2;
   end Fig_Pentagonal;

   -------------------
   -- Fig_Hexagonal --
   -------------------

   function Fig_Hexagonal  (N : Natural) return Natural is
   begin
      return N * (2 * N - 1);
   end Fig_Hexagonal;

   --------------------
   -- Fig_Heptagonal --
   --------------------

   function Fig_Heptagonal (N : Natural) return Natural is
   begin
      return N * (5 * N - 3) / 2;
   end Fig_Heptagonal;

   -------------------
   -- Fig_Octagonal --
   -------------------

   function Fig_Octagonal  (N : Natural) return Natural is
   begin
      return N * (3 * N - 2);
   end Fig_Octagonal;

   -----------------
   -- Full_Reduce --
   -----------------

   procedure Full_Reduce (Sequence : in out Sequence_Type;
                          Result   :    out Flatten_Result)
   is
      Single_Count : Natural := 0;
      Pos : Index_Type := Index_Type'First;
      Next_Pos : Index_Type;
      Length : Ada.Containers.Count_Type;
      use type Ada.Containers.Count_Type;
   begin
      loop
         Next_Pos := Pos + 1;
         Reduce (Sequence (Pos), Sequence (Next_Pos));

         Length := Sequence (Next_Pos).Length;

         if Length = 0 then
            Result := No_Solution;
            return;
         end if;

         if Length = 1 then
            Single_Count := Single_Count + 1;

            if Single_Count = Index_Type'Modulus then
               Result := Solved;
               return;
            end if;
         else
            Single_Count := 0;
         end if;

         Pos := Next_Pos;
      end loop;
   end Full_Reduce;

   ------------------
   -- Get_In_Range --
   ------------------

   function Get_In_Range (Low, High : Natural;
                          Generate : access function (N : Natural)
                            return Natural)
                         return Natural_Vector
   is
      Result : Natural_Vector;
      N, Tmp : Natural;
   begin
      N := 1;
      loop
         Tmp := Generate (N);
         exit when Tmp > High;
         if Tmp >= Low then
            Result.Append (Tmp);
         end if;
         N := N + 1;
      end loop;

      return Result;
   end Get_In_Range;

   ---------------------
   -- Initialize_Base --
   ---------------------

   procedure Initialize_Base is
   begin
      for I in Generators'Range loop
         Base_Sequence (I) := Get_In_Range (1000, 9999,
                                            Generators (I));
      end loop;
   end Initialize_Base;

   ------------
   -- Reduce --
   ------------

   procedure Reduce (Source :        Natural_Vector;
                     Dest   : in out Natural_Vector)
   is
      Result : Natural_Vector;
      Reachable : Boolean;
      Ndiv : Natural;
   begin
      for Num of Dest loop
         Ndiv := Num / 100;
         Reachable := False;
         for Snum of Source loop
            if Snum mod 100 = Ndiv then
               Reachable := True;
               exit;
            end if;
         end loop;

         if Reachable then
            Result.Append (Num);
         end if;
      end loop;

      Dest := Result;
   end Reduce;

   Temp : Sequence_Type;
   Temp_Solved : Flatten_Result;

   package Permuter is new Permutations (Natural);

   Perms : Permuter.Permutation_State (Natural (Index_Type'First),
                                       Natural (Index_Type'Last));
   Swap : Permuter.Swap_Type;
   Done : Boolean;

   Sum : Natural := 0;

begin
   Initialize_Base;
   loop
      Temp := Base_Sequence;
      Full_Reduce (Temp, Temp_Solved);
      if Temp_Solved = Solved then
         exit;
      end if;

      --  Advance to the next permutation.
      Permuter.Next_Permutation (Perms, Swap, Done);
      if Done then
         Put_Line ("No solution found");
         exit;
      end if;

      declare
         Hold : constant Natural_Vector := Base_Sequence (Index_Type (Swap.A));
      begin
         Base_Sequence (Index_Type (Swap.A)) :=
           Base_Sequence (Index_Type (Swap.B));
         Base_Sequence (Index_Type (Swap.B)) := Hold;
      end;
   end loop;

   for I in Temp'Range loop
      Sum := Sum + Temp (I).First_Element;
   end loop;

   Put_Line (Natural'Image (Sum));
end Pr061;
