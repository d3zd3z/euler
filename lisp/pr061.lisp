;;; Problem 61
;;;
;;; 16 January 2004
;;;
;;; Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
;;; are all figurate (polygonal) numbers and are generated by the following
;;; formulae:
;;;
;;; Triangle     P[3,n]=n(n+1)/2    1, 3, 6, 10, 15, ...
;;; Square       P[4,n]=n^2         1, 4, 9, 16, 25, ...
;;; Pentagonal   P[5,n]=n(3n−1)/2   1, 5, 12, 22, 35, ...
;;; Hexagonal    P[6,n]=n(2n−1)     1, 6, 15, 28, 45, ...
;;; Heptagonal   P[7,n]=n(5n−3)/2   1, 7, 18, 34, 55, ...
;;; Octagonal    P[8,n]=n(3n−2)     1, 8, 21, 40, 65, ...
;;;
;;; The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
;;; interesting properties.
;;;
;;;  1. The set is cyclic, in that the last two digits of each number is the
;;;     first two digits of the next number (including the last number with
;;;     the first).
;;;  2. Each polygonal type: triangle (P[3,127]=8128), square (P[4,91]=8281),
;;;     and pentagonal (P[5,44]=2882), is represented by a different number in
;;;     the set.
;;;  3. This is the only set of 4-digit numbers with this property.
;;;
;;; Find the sum of the only ordered set of six cyclic 4-digit numbers for
;;; which each polygonal type: triangle, square, pentagonal, hexagonal,
;;; heptagonal, and octagonal, is represented by a different number in the
;;; set.
;;;
;;; 28684

(defpackage #:pr061
  (:use #:cl #:iterate #:pr024)
  (:export #:euler-61))
(in-package #:pr061)

(defun triangle (n)
  (/ (* n (1+ n)) 2))
(defun square (n)
  (* n n))
(defun pentagonal (n)
  (/ (* n (1- (* 3 n)))
     2))
(defun hexagonal (n)
  (* n (1- (* 2 n))))
(defun heptagonal (n)
  (/ (* n (- (* 5 n) 3))
     2))
(defun octagonal (n)
  (* n (- (* 3 n) 2)))

(defun in-range (op low high)
  "Generate values of (op n) for n starting at 1, and collect all of
the results >= low that are <= high"
  (iter (for n from 1)
	(for p = (funcall op n))
	(until (> p high))
	(when (>= p low)
	  (collect p))))

(defun possible-sets (low high)
  "Generate all of the possible sets."
  (mapcar #'(lambda (op)
	      (in-range op low high))
	  (list #'triangle #'square #'pentagonal
		#'hexagonal #'heptagonal #'octagonal)))

(defun follows (a b)
  "Can B follow A according to the rules of the problem?"
  (= (mod a 100)
     (floor b 100)))

(defun reduce-sets (as bs)
  "Return a reduced version of AS only including ones where (FOLLOWS A
B) is true for some member B of BS."
  (remove-if-not #'(lambda (b)
		     (find-if #'(lambda (a)
				  (follows a b))
			      as))
		 bs))

(defun reduction-step (sets)
  "Perform a reduction step on the first two sets in SETS.  Returns a
new list of sets, with the tail rotated into the front position, and
the new second reduced.  Returns the length of the reduced set as the
second argument."
  (let* ((as (first sets))
	 (bs (second sets))
	 (others (cddr sets))
	 (reduction (reduce-sets as bs)))
    (values (append (cons reduction others) (list as))
	    (length reduction))))

(defun full-reduction (sets)
  "Reduce the sets until the problem either reaches a fixedpoint of
'1' element sets, or an empty set.  Returns the numbers if this is a
solution, or NIL if there isn't a solution with these sequences."
  (iter (initially (setq s sets))
	(with counter = 0)
	(for limit-counter from 1)
	(when (> limit-counter 500)
	  (return-from full-reduction nil))
	(for (values s count) next (reduction-step s))
	(when (zerop count)
	  (return-from full-reduction nil))
	;; (format t "reduce: ~S~%" s)
	(cond ((= count 1)
	       (incf counter)
	       (when (= counter 7)
		 (return-from full-reduction s)))
	      (t (setf counter 0)))))

;;; The permutation functions in pr024 want an array that can be
;;; compared with '<'.  Make up an array of pairs with the integers.
(defun build-array (lst)
  (iter (for item in lst)
	(for index from 1)
	(collect (cons index item) result-type 'vector)))

(defun node-< (a b)
  (< (car a) (car b)))

(defun node-contents (vec)
  (mapcar #'cdr (coerce vec 'list)))

(defun euler-61 ()
  (iter (for seq first (build-array (possible-sets 1000 9999))
	     then (next-permutation seq :less #'node-<))
	(when (not seq)
	  (error "Failed to find answer"))
	(for reduction = (full-reduction (node-contents seq)))
	(when reduction
	  (return-from euler-61
	    (reduce #'+
		    (mapcar #'car reduction)))))
  nil)
