// Problem 45
//
// 06 June 2003
//
//
// Triangle, pentagonal, and hexagonal numbers are generated by the following
// formulae:
//
// Triangle     T[n]=n(n+1)/2    1, 3, 6, 10, 15, ...
// Pentagonal   P[n]=n(3n−1)/2   1, 5, 12, 22, 35, ...
// Hexagonal    H[n]=n(2n−1)     1, 6, 15, 28, 45, ...
//
// It can be verified that T[285] = P[165] = H[143] = 40755.
//
// Find the next triangle number that is also pentagonal and hexagonal.

// use std::cmp::Ordering;

define_problem!(pr045, 45, 1533776805);

// Simple, uninteresting version.
#[cfg(never)]
fn pr045a() -> u64 {
    let mut pn = 1;
    let mut hn = 1;
    let mut pentagonal = 1;
    let mut hexagonal = 1;

    loop {
        if pentagonal == hexagonal && pentagonal > 40755 {
            return pentagonal
        }

        if pentagonal < hexagonal {
            pn += 1;
            pentagonal += 3 * pn - 2;
        } else {
            hn += 1;
            hexagonal += 4 * hn - 3;
        }
    }
}

// Interesting version that uses some custom iterators.
fn pr045() -> i64 {
    let mut pents = NumberSequence::new_pentagonal();
    let mut hexs = NumberSequence::new_hexagonal();
    let mut both = Sames::new(&mut pents, &mut hexs);

    loop {
        match both.next() {
            Some(aa) if aa > 40755 => return aa,
            Some(_) => (),
            None => panic!("Shouldn't be reached"),
        }
    }
}

// To make the solution more interesting, lets make some interesting
// iterators.

struct NumberSequence {
    index: i64,
    value: i64,
    mult: i64,
    add: i64,
}

impl NumberSequence {
    fn new(mult: i64, add: i64) -> NumberSequence {
        NumberSequence {
            index: 1,
            value: 1,
            mult,
            add,
        }
    }

    fn new_pentagonal() -> NumberSequence {
        NumberSequence::new(3, -2)
    }

    fn new_hexagonal() -> NumberSequence {
        NumberSequence::new(4, -3)
    }
}

impl Iterator for NumberSequence {
    type Item = i64;

    fn next(&mut self) -> Option<i64> {
        let result = self.value;

        self.index += 1;
        self.value += self.mult * self.index + self.add;

        Some(result)
    }
}

//----------------------------------------------------------------------
// This iterator combines two other numeric iterators, and assuming both
// iterators return increasing sequences, returns the elements that are the
// same from both.

struct Sames<'a, T> {
    aiter: &'a mut dyn Iterator<Item=T>,
    biter: &'a mut dyn Iterator<Item=T>,
    acur: Option<T>,
    bcur: Option<T>,
}

impl<'a, T> Sames<'a, T> {
    fn new<'b>(a: &'b mut dyn Iterator<Item=T>, b: &'b mut dyn Iterator<Item=T>) -> Sames<'b, T> {
        let acur = a.next();
        let bcur = b.next();
        Sames {
            aiter: a,
            biter: b,
            acur,
            bcur,
        }
    }
}

// Implement this for things that can be compared and copied.
// TODO: Come up with an API that doesn't need `Copy` or `Clone`.
impl<'a, T> Iterator for Sames<'a, T>
    where T: Ord + Copy
{
    type Item = T;

    fn next(&mut self) -> Option<T> {
        loop {
            match (self.acur, self.bcur) {
                (Some(aa), Some(bb)) => {
                    if aa < bb {
                        self.acur = self.aiter.next();
                    } else if aa > bb {
                        self.bcur = self.biter.next();
                    } else {
                        self.acur = self.aiter.next();
                        self.bcur = self.biter.next();
                        return Some(aa);
                    }
                },
                _ => return None
            }
        }
    }
}

#[cfg(broken)]
impl<'a, T> Iterator for Sames<'a, T>
    where T: Ord
{
    type Item = &'a T;

    fn next(&mut self) -> Option<&'a T> {
        loop {
            let ord = match (&self.acur, &self.bcur) {
                (&Some(ref aa), &Some(ref bb)) => aa.cmp(bb),
                _ => return None,
            };

            match ord {
                Ordering::Less => self.acur = self.aiter.next(),
                Ordering::Greater => self.bcur = self.biter.next(),
                _ => {
                    let result = self.acur;
                    result
                }
            }
        }
    }
}
