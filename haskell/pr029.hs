----------------------------------------------------------------------
-- Consider all integer combinations of a^(b) for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
--
--     2^(2)=4, 2^(3)=8, 2^(4)=16, 2^(5)=32
--     3^(2)=9, 3^(3)=27, 3^(4)=81, 3^(5)=243
--     4^(2)=16, 4^(3)=64, 4^(4)=256, 4^(5)=1024
--     5^(2)=25, 5^(3)=125, 5^(4)=625, 5^(5)=3125
--
-- If they are then placed in numerical order, with any repeats
-- removed, we get the following sequence of 15 distinct terms:
--
-- 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
--
-- How many distinct terms are in the sequence generated by a^(b) for
-- 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
----------------------------------------------------------------------

module Main where

import Data.List (sort, group)
import qualified Data.Set as Set
import Data.Set (Set)

import Primes

main :: IO ()
main = print answer

--  where answer = length $ group $ sort [ a^b | a <- [(2::Integer)..100], b <- [2..100] ]

-- Although the above certainly works (and appears to still be quite
-- fast), let's come up with one that can use regular Ints.  The key
-- to this is to realize that although the numbers themselves will
-- grow quite large, the factors are never all that large (largest is
-- 97).  So, factor the numbers, and do the exponentiation and
-- comparisons with the factorized representation.

power :: [(Int, Int)] -> Int -> [(Int, Int)]
power [] _ = []
power ((x,y):xs) b = (x,y*b) : power xs b

answer = Set.size $ Set.fromList all
   where
      all = [ power a b | a <- aFactored, b <- [2..100] ]
      aFactored = map primeFactors [2..100]
