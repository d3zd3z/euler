----------------------------------------------------------------------
-- Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
-- numbers are all figurate (polygonal) numbers and are generated by
-- the following formulae:
-- Triangle             P3,n=n(n+1)/2           1, 3, 6, 10, 15, ...
-- Square               P4,n=n2                 1, 4, 9, 16, 25, ...
-- Pentagonal           P5,n=n(3n−1)/2          1, 5, 12, 22, 35, ...
-- Hexagonal            P6,n=n(2n−1)            1, 6, 15, 28, 45, ...
-- Heptagonal           P7,n=n(5n−3)/2          1, 7, 18, 34, 55, ...
-- Octagonal            P8,n=n(3n−2)            1, 8, 21, 40, 65, ...
--
-- The ordered set of three 4-digit numbers: 8128, 2882, 8281, has
-- three interesting properties.
--
-- 1. The set is cyclic, in that the last two digits of each number
--    is the first two digits of the next number (including the last
--    number with the first).
-- 2. Each polygonal type: triangle (P3,127=8128), square
--    (P4,91=8281), and pentagonal (P5,44=2882), is represented
--    by a different number in the set.
-- 3. This is the only set of 4-digit numbers with this
--    property.
--
-- Find the sum of the only ordered set of six cyclic 4-digit numbers
-- for which each polygonal type: triangle, square, pentagonal,
-- hexagonal, heptagonal, and octagonal, is represented by a
-- different number in the set.
----------------------------------------------------------------------
-- 28684

module Main where

import Data.List (permutations)
import Data.Maybe (catMaybes)

main :: IO ()
main = putStrLn $ show solve

solve :: Int
solve = sum $ head $ catMaybes $ map pairReduce $ permutations $ getSets 1000 9999

-- Given a [low..high] range, return lists for each of the types of
-- numbers that fall in that range.
getSets :: Int -> Int -> [[Int]]
getSets low high = map single [triangles, squares, pentagonals,
                               hexagonals, heptagonals, octagonals]
  where
    single fn = takeWhile (<=high) $
                dropWhile (<low) [ fn x | x <- [1..] ]
    triangles n   = n * (n + 1) `div` 2
    squares n     = n * n
    pentagonals n = n * (3 * n - 1) `div` 2
    hexagonals n  = n * (2 * n - 1)
    heptagonals n = n * (5 * n - 3) `div` 2
    octagonals n  = n * (3 * n - 2)

-- Return the subset of the second set that is reachable by the above rules.
subset :: [Int] -> [Int] -> [Int]
subset a b = filter reachable b
  where
    reachable bb = any (\aa -> aa `mod` 100 == bb `div` 100) a

pairFold :: (a -> a -> a) -> [a] -> [a]
pairFold op (a : b : rest) =
  let ab = op a b in
  ab : pairFold op (ab:rest)
pairFold _ x = x

pairReduce :: [[Int]] -> Maybe [Int]
pairReduce items = check $ pairFold subset $ cycle items
  where
    check ([a]:[b]:[c]:[d]:[e]:[f]:[_]:_) = Just [a,b,c,d,e,f]
    check ([]:_) = Nothing
    check (_:xs) = check xs
    check [] = undefined
